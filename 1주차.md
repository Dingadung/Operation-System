# operating system(운영체제)
> 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어

1. 운영체제는 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.
2. 소프트웨어가 컴퓨터 시스템에서 실행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 한다.
⇒ 운영체제 자체도 하나의 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라간다.

## kernel(커널)
> 메모리에 상주하는 운영체제의 부분으로,
운영체제 코드 중에서도 핵심적인 부분을 뜻한다.

## 운영체제의 기능
1. 하드웨어를 위한 역할
사용자가 직접 다루기 힘든 각종 하드웨어 관리
(컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것)
2. 사용자를 위한 역할
편리한 인터페이스를 제공하는 역할
(컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공)


---
# Basic Elements
## Processor(CPU)
> 하드웨어적인 측면에서 "컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛"이다.

1. 이는 **중앙처리장치(Central Processing Unit, CPU)** 를 뜻하며,
폰노이만 아키텍쳐에 의해 만들어졌다면 적어도 하나 이상의 ALU (Arithmetic Logic Unit)와 처리 레지스터(Register)를 내장하고 있어야 한다.
2. CPU는 **메인 메모리** 와 프로세서 자체에 내장된 **레지스터** 에만 직접 접근할 수 있다.

### Process 
> 메모리에 적재되어 프로세서에 의해 실행중인 프로그램

### 컴퓨터가 프로그램을 실행하는 과정
1. 사용자가 단축 아이콘 혹은 명령행에서 프로그램을 실행한다.
2. 파일로 저장되어 있던 프로그램은 메모리(램)에 로더(Loader)에 의해 적재(load)되고 처음으로 실행해야 할 기계어 코드가 저장된 메모리의 주소를 CPU의 명령주소(IP : Instruction Pointer) 레지스터에 저장한다.
3. 프로세서(CPU)는 IP 레지스터가 가리키는 메모리의 주소에서 (처음으로) 실행할 명령어를 인출(메모리에서 CPU로 가져오는)하여 명령 레지스터(IR : Instruction Register)에 저장한다.
4. IR에 저장된 명령을 실행하고 IP에 다음번에 실행할 명령어가 있는 주소를 저장한다.
5. 3~4를 프로그램의 끝까지 반복한다.

## Main Memory(RAM)
1. 주기억장치(Random Access Memory)
2. volatile
컴퓨터의 CPU가 현재 처리중인 데이터나 명령어만을 일시적으로 저장하는 휘발성 메모리이다.
⇒ 전원이 꺼지면 메인 메모리에 저장되어 있던 모든 내용들은 사라지게 된다.
⇒ 따라서 전원이 꺼지더라도 데이터를 유지하고 싶다면, 
데이터를 하드 디스크에 저장해야한다.
3. **프로그램**은 실행되기 전까지 단지 디스크에 저장되어있는 **이진 실행파일**에 불과하다.
→ 실행을 위해 **메인 메모리**에 올라가는 순간 비로소 **프로세스**가 된다.

![](https://velog.velcdn.com/images/mini_mouse_/post/7fdf062e-7eab-468d-95d8-ad62be96d7e7/image.png)


## Register
> 레지스터는 CPU(Central Processing Unit)가 요청을 처리하는 데 필요한 데이터를 **일시적으로 저장**하는 **기억장치**이다.

![](https://velog.velcdn.com/images/mini_mouse_/post/2840f189-9d6d-4f0c-a9a0-8bd9e98b8b78/image.png)

1. 레지스터는 공간은 작지만,
CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 실제 수십 배에서 수백 배까지 빠르다.

2. 실제로 컴퓨터에서 데이터를 영구적으로 저장하기 위해서는 하드디스크를 이용해야 하고, 임시적으로 저장하는 장소를 메모리(RAM)라고 한다.

3. 레지스터 크기?
32bit or 64bit (더 정확히 system bus의 크기)
⇒ 크기가 클 수록 한 번에 데이터가 많이 움직여서 속도가 빨라진다.

하지만, 메모리로 연산의 결과를 보내고 영구적으로 저장할 데이터를 하드디스크에 저장해야 하는 등의 **명령을 처리** 하기 위해서는
이들에 대한 **주소와 명령의 종류를 저장할 수 있는 기억 공간**
이 하나 더 필요하다.
그리고 이 공간은 무리 없이 명령을 수행하기 위해 **메모리보다 빨라**야 한다.
바로 이런 역할들을 하는 것이 CPU옆에 붙어있는 레지스터이다.
그리고 **CPU는 자체적으로 데이터를 저장할 방법이 없기** 때문에 메모리로 직접 데이터를 전송할 수 없다.
때문에 **연산을 위해서는 반드시 레지스터를 거쳐야 하며**, 
이를 위해서 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있다.

## I/O modules
- secondary memory devices (disks)
- communications equipment
- terminals

## System bus
- communication among processors, memory , and I/O moduels

---
# Computer Component:<br>Top-Level View
![](https://velog.velcdn.com/images/mini_mouse_/post/7b542a6c-80c3-4ea1-ae99-4f7588463fca/image.png)

- Program = Instruction + Data

## CPU 전용 레지스터 (중요)
### AC(Accumulator, 누산기)
> 데이터를 일시 저장하는 레지스터

1. 데이터를 AC에 집어 넣으면 특별한 레지스터 mbr을 통해 데이터를 보내게 된다.
2. 기억장치로부터의 읽어온 데이터와 누산기에 적재되어 있던 데이터가 지정된 연산을 수행한 후, 
그 결과 값을 다시 누산기에 적재한다. 
3. 누산기 내용을 전부 지워 0으로 만들 수 있다. 
4. 왼쪽이나 오른쪽으로 몇 자리씩 움직일 수도 있다. 
5. 누산기의 비트 수는 CPU가 한 번에 처리할 수 있는 데이터 비트 수인 word의 길이와 같다.
5. 가지고 있는 값
   - 데이터 일시저장
   - AC = AC의 현재 값 + 메모리로부터 읽어온 값

### PC(Program counter)
> 다음에 실행할 명령어의 주소를 저장하는 레지스터


### IR(Instruction Register)
> 현재 실행중인 명령어를 기억하는 레지스터

### MAR(Memory Address Register, 기억장치주소 레지스터)
> 다음에 수행될 명령어를 인출하기 위해 현재 PC에 들어 있는 내용(주소)이 
시스템 주소버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터

1. PC → MAR
2. instruction
프로그램 카운터에서 가져오는 거 X,
PC → MAR 옮겨서 가져오는 거 O

### MBR(Memory Buffer Register, 기억장치버퍼 레지스터)
> 레지스터와 외부에 연결되는 장치사이에서 전송되는 데이터의 전송통로이다.
기억장치로 쓰일 데이터나 기억장치로부터 읽어온 데이터를 임시로 저장하는 레지스터

**CPU 안에 있는 모든 레지스터가 메모리에 연결되는게 아니라,
CPU 안으로 들어오는 모든 명령어들과 데이터들은 MBR을 거친다.**

MAR의 실제 콘텐츠(데이터, 명령어)가 들어있다.

![](https://velog.velcdn.com/images/mini_mouse_/post/374ce7b7-35b8-4f57-93ed-37324512c29b/image.png)



### I/O AR(Input/Output Address Register)
입출력에 이용됨

### I/O BR(Input/Output Address Buffer Register)
입출력에 이용됨

---
# Instructions
## Program
> 일반적으로 하드 디스크 등에 저장되어 있는 실행 코드
program = instructions + data

## Instruction의 종류
1. Processor-memory data transfer
메모리 몇번지에 있는 데이터를 cpu로 옮겨라
2. Processor-I/O data transfer
cpu ↔ IO
3. Data processing 
더하기 뺴기, and, or
4. Control
jump 명령어

## Instruction Execution
### Two Steps
1. Processor가 memory로부터 명령어들을 읽어 온다.
2. Processor가 각각의 명령어를 실행한다.
### Basic Instruction Cycle (중요)
Fetch Stage: 메모리에서 instruction을 가져오기
Execute Stage: 명령어 분석 후 실행
![](https://velog.velcdn.com/images/mini_mouse_/post/7addcb1e-742c-43e6-b725-a85ed16c70cf/image.png)

시작 → 다음 명령어 가져오기 → 명령어 실행 → 정지(오류 X)

## Example of Program Execution
![](https://velog.velcdn.com/images/mini_mouse_/post/4b9a0096-5922-4eef-9c72-66a64ed23a3b/image.png)

---
# Control and Status Registers (중요)
## PC
다음에 실행할 명령어의 주소 저장
## IR
현재 실행할 명령어의 주소 저장
## PSW(Progam Status Word)
> 
**CPU의 현재 상태 정보 저장**
시스템 내부의 순간순간의 상태를 기록하고 있는 정보

- 시스템을 관리하는데 필요한 여러가지 상황을 이 레지스터에 저장해둔것이다.
**에러를 최소화**하고 시스템 전체에 영향을 안미치게 하기 위해 저장해두는 것이다.
- 비트마다 목적을 다르게 해서 여러가지 정보를 저장해둔다.
- **CPU의 연산 결과**에 따라 상태가 PSW에 저장되며, 
이 중에 인터럽트를 알리는 비트 5bit가 있고, 
5가지 ISR(인터럽트 서비스 루틴)이 운영체제 일부에 존재
- 인터럽트 처리 중 다른 인터럽트 발생 시, 운선순위에 의해 인터럽트 처리
- 세가지 정보를 갖는다.
   1. Condition codes
   (상태 코드, 점프를 할지 말지 결정하는데 사용하는 코드)
   2. Interrupt enable/disable
   (인터럽트 활성화 여부)
   3. Supervisor/user mode